# CS-300


# What was the problem you were solving in the projects for this course?

In this course I worked on two main projects. The first focused on analyzing the runtime and memory usage of different data structures such as vectors, hash tables, and binary search trees. The second project required me to build a program that could load, sort, and print a list of computer science courses in alphanumeric order. Together, these projects helped me understand how data structures impact efficiency and performance.

# How did you approach the problem?

I approached the problems by breaking them into smaller steps. First, I reviewed the strengths and weaknesses of each data structure. For example, vectors are simple to use but have slower search times, while hash tables are faster for lookups but use more memory. Understanding these trade-offs showed me why choosing the right structure matters when solving programming problems.

# How did you overcome any roadblocks you encountered while going through the activities or project?

One of the main challenges I faced was getting my code to properly read the data from the file. At first, my program wasnâ€™t pulling in the information the way I expected, which made it hard to test whether the rest of the logic was correct. To overcome this, I slowed down and added extra print statements to check what was actually being read in. I also compared my process to the pseudocode I had written earlier, which helped me spot where I was going wrong. Once I fixed the data loading issue, the rest of the program came together more smoothly.

# How has your work on this project expanded your approach to designing software and developing programs?

These projects expanded my approach by showing me that design decisions happen before writing code. Thinking about the data structures, the flow of the program, and the trade-offs between performance and memory made me more intentional in my choices. I now see how planning upfront saves time later in development.

# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

I learned to write code that is better organized and easier to read. For example, I used functions to separate tasks like loading data, sorting, and printing results. I also added comments to explain my logic so that someone else (or future me) can understand the program more easily. These practices will help me create programs that can be maintained or modified without starting from scratch.
